import { createServer, Server } from 'http';
import express from 'express';
import socketIo = require('socket.io');
import { Subscription } from 'rxjs';
import { ConcealedBehaviorSubject } from './ConcealedBehaviorSubject';
import { ConcealedSubject } from './ConcealedSubject';
import { SocketServerMessages } from './SocketServerMessages';
import { isObject } from 'util';
import SerialPort from 'serialport';
import { PortInfo } from 'serialport';
const Readline = require('@serialport/parser-readline')


enum ProxyServerMessages {
    connect = 'connect',
    serialDataSend = 'serial-data-send',
    serialDataJson = 'serial-data-json',
    serialDataJMsg = 'serial-data-msg',
    serialOpenStatus = 'serial-open',
    serialPortsList = "serial-ports-list",
    disconnect = 'disconnect',
    serialDisconnectPort = "serial-disconnect-port",
    serialConnectToPort = "serial-connect-port",
    serialServerPing = "serial-server-ping",
    serialRpcRequest = 'serial-rpc-request',
    serialRpcResponse = 'serial-rpc-response'
}

//express 
const portNumber = 3007;
const app = express();
const server = createServer(app);

// socket io
const io = socketIo(server, { origins: '*:*' });
//var io = require('socket.io')(server, { origins: '*:*'});
const socketsConnected: SocketIO.Socket[] = [];

// serial port
let currentPort = "COM23";
let currentBaud = 57600;
export let serialPort = new SerialPort(currentPort, { autoOpen: false, baudRate: currentBaud });

const serialMsgs = new ConcealedSubject<string>();
const serialJson = new ConcealedSubject<Object>();
const serialRpc = new ConcealedSubject<Object>();
const serialOpenStatus = new ConcealedBehaviorSubject<boolean>(false);

serialOpenStatus.observable.subscribe((s) => console.log(s ? "serial port opened" : "port closed"));

function disconnectFromSerialPort() {
    if (serialPort) {
        serialPort.close((e) => {

        });
        currentBaud = 0;
        currentPort = '';
    }
}
function connectToSerialPort(port: string, baud: number) {


    serialPort = new SerialPort(port, { baudRate: baud }, function (err) {
        if (err) {
            return console.log('Error: ', err.message)
        }

        currentBaud = baud;
        currentPort = port;
    });

    // open
    serialPort.on('open', function () {
        serialOpenStatus.next(true);
    })

    // close
    serialPort.on('close', function () {
        serialOpenStatus.next(false);
    })

    // data
    const lineStream = serialPort.pipe(new Readline())
    lineStream.on('data', (data) => {
        try {
            let json = JSON.parse(data);
            if (json) {
                console.log(json);
                serialJson.next(json);
                if(json.j && json.j==2){
                    serialRpc.next(json);
                }
            }
        } catch (error) {
            serialMsgs.next(data);
            console.log("json error");
        }
    });


}
connectToSerialPort(currentPort, currentBaud);

// start express
server.listen(portNumber, () => {
    console.log('Running server on port %s', portNumber);
});
 

io.on(ProxyServerMessages.connect, async (socket: SocketIO.Socket) => {
    let subSerialOpenStatus: Subscription;
    let subSerialJsonData: Subscription;
    let subMessageData: Subscription;
    let subSerialRpcData: Subscription;
    console.log("connected");

    //Open status
    subSerialOpenStatus = serialOpenStatus.observable.subscribe((r) => {
        socket.emit(ProxyServerMessages.serialOpenStatus, r);
    })
    // Relay Json Objects
    subSerialJsonData = serialJson.observable.subscribe((r) => {
        socket.emit(ProxyServerMessages.serialDataJson, r);
    })
    // Relay Msg Objects
    subMessageData = serialMsgs.observable.subscribe((r) => {
        socket.emit(ProxyServerMessages.serialDataJMsg, r);
    })
        // Relay Msg Objects
        subSerialRpcData = serialRpc.observable.subscribe((r) => {
            socket.emit(ProxyServerMessages.serialRpcResponse, r);
        })
    // Relay send data
    socket.on(ProxyServerMessages.serialDataSend, async (m: any) => {
        console.log(m);
        try {
            serialPort.write(m + '\n');
        } catch (error) {
            console.log(error);
        }
    });
    // Relay send json data
    socket.on(ProxyServerMessages.serialDataJson, async (m: any) => {
        console.log(m);
        try {
            if (isObject(m)) {
                serialPort.write(JSON.stringify(m) + '\n');

                
            }
            else {
                throw "not object "
            }

        } catch (error) {
            console.log(error);
        }
    });

    // Relay send message
    socket.on(ProxyServerMessages.serialDataJMsg, async (m: any) => {
        console.log(m);
        try {
            serialPort.write(m + '\n');
        } catch (error) {
            console.log(error);
        }
    });
    //  
    socket.on(ProxyServerMessages.serialRpcRequest, async (m: any) => {
        console.log({rpc:m});
        try {
            serialPort.write(m + '\n');
        } catch (error) {
            console.log(error);
        }
    });


    // serial ports list
    socket.on(ProxyServerMessages.serialPortsList, async (m: any) => {
     

        SerialPort.list().then((ports) => {
            console.log("Port: ", ports);
            const serialPorts = ports.map(m => m.comName);
            const result = {
                ports: serialPorts,
                bauds: [9600, 57600, 115200],
                selectedPort: currentPort,
                selectedBaud: currentBaud

            } as ISerialPorts;
            socket.emit(ProxyServerMessages.serialPortsList, result);
        });
    });

    // disconnect port
    socket.on(ProxyServerMessages.serialDisconnectPort, async (m: any) => {

        disconnectFromSerialPort();
        socket.emit(ProxyServerMessages.serialDisconnectPort, { result: true });

    });
    // connect port 
    socket.on(ProxyServerMessages.serialConnectToPort, async (m: any) => {
        if (m && m.port && m.baud) {
            disconnectFromSerialPort();
            connectToSerialPort(m.port, m.baud);
        }
        disconnectFromSerialPort();
        socket.emit(ProxyServerMessages.serialConnectToPort, { result: true });

    });
    // server ping
    socket.on(ProxyServerMessages.serialServerPing, async (m: any) => {
       
        socket.emit(ProxyServerMessages.serialServerPing, m);

    });
    // disconnect close subscriptions
    socket.on(SocketServerMessages.disconnect, async () => {
        subSerialOpenStatus.unsubscribe();
        subSerialJsonData.unsubscribe();
        subMessageData.unsubscribe();
        console.log("socket client disconnect");
    });

});

export interface ISerialPorts {
    ports: string[];
    bauds: number[];
    selectedPort: string;
    selectedBaud: number;
}